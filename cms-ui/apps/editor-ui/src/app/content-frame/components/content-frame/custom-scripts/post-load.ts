/* eslint-disable no-underscore-dangle */
import { AlohaIntegrationService } from '@editor-ui/app/content-frame/providers';
import { Page } from '@gentics/cms-models';
import { typeIdsToName } from '@gentics/cms-components';
import { ALOHAPAGE_URL, API_BASE_URL } from '../../../../common/utils/base-urls';
import { CNIFrameDocument, CNWindow, DYNAMIC_FRAME, GCNJsLibRequestOptions } from '../../../models/content-frame';
import { CustomScriptHostService } from '../../../providers/custom-script-host/custom-script-host.service';

export const OBJECT_PROPERTIES_CONTEXT_MENU_CLASS = 'custom-object-properties-context-menu-button';

export const OBJECT_PROPERTIES_INFO_BUTTON_CLASS = 'custom-object-properties-info-button';

const ATTR_OBJECT_ID = 'data-gentics-aloha-object-id';
const ATTR_NODE_ID = 'data-gcn-channelid';
const ATTR_REPO = 'data-gentics-aloha-repository';
const REPO_CMS_ITEM = 'com.gentics.aloha.GCN.Page';
const FILE_LINK_PREFIX = `${API_BASE_URL}/file/content/load`;

interface InternalLink {
    nodeId?: number;
    type: 'file' | 'image' | 'page' | 'form';
    itemId: number;
}

/**
 * This will execute in the context of the IFrame, when the code inside it calls the `GCMSUI.runPostLoadScript()` method.
 * This occurs when the document's `load` event fires (i.e. full document and all resources are loaded).
 *
 * Scripts that need to manipulate DOM which may itself be generated by other scripts on the page (such as the tagfill
 * stuff) needs to go in here.
 *
 * For scripts that do not rely on generated DOM, use the pre-load function.
 *
 * We pass in the instance of the ScriptHost so that we can refer back to that scope and interact directly it.
 */
export class PostLoadScript {

    private editablesChanged = false;
    private pageIsSavingFromSaveButton = false;

    constructor(
        private iFrameWindow: CNWindow,
        private iFrameDocument: CNIFrameDocument,
        private scriptHost: CustomScriptHostService,
        private aloha: AlohaIntegrationService,
    ) { }

    run(): void {
        this.setupAlohaHooks(this.iFrameWindow);

        // Determine which type of editor frame is opened (previewing page, tagfill, ...)
        const editFrameType = this.determineEditFrameType();

        // Depending on the frame type, do the right things
        switch (editFrameType) {
            case 'editPage':
            case 'previewPage':
                this.handleClickEventsOnLinks();
                this.notifyWhenContentsChange();
                break;
        }

        this.scriptHost.runChangeDetection();
    }

    private setupAlohaHooks(iFrameWindow: CNWindow): void {
        if (!this.aloha) {
            return;
        }

        this.aloha.setWindow(iFrameWindow);

        // In case of an error, the Aloha property may not be present.
        if (iFrameWindow.Aloha != null) {
            this.aloha.reference$.next(iFrameWindow.Aloha);
            this.aloha.settings$.next(iFrameWindow.Aloha.settings);
            iFrameWindow.Aloha.ready(() => {
                this.aloha.ready$.next(true);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                this.aloha.windowLoaded$.next(true);
            });
        } else {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            this.aloha.windowLoaded$.next(true);
        }

        iFrameWindow.addEventListener('unload', () => {
            this.aloha.settings$.next(null);
            this.aloha.reference$.next(null);
        });
    }

    determineEditFrameType(): 'tagfill' | 'editPage' | 'editImage' | 'objectProperties' | 'objectPropertiesNoValidation' | 'previewPage' {
        const frameElement = this.iFrameWindow.frameElement as HTMLElement;
        const isDynamicFrame = frameElement && frameElement.dataset[DYNAMIC_FRAME] === 'true';
        const isValidationDisabled = frameElement && frameElement.dataset['disableValidation'] === 'true';

        if (isDynamicFrame) {
            return 'tagfill';
        }

        const objectPropertiesOkayButton = this.iFrameDocument.querySelector('input[type="image"][name="factionok"]');
        if (objectPropertiesOkayButton) {
            return 'objectProperties';
        }

        if (this.iFrameDocument && this.iFrameDocument.body &&
            this.iFrameDocument.body.dataset['itemType'] === 'image' &&
            this.iFrameDocument.body.dataset['editMode'] === 'edit') {
            return 'editImage';
        }

        switch (this.scriptHost.editMode) {
            case 'compareVersionContents':
            case 'compareVersionSources':
            case 'preview':
            case 'previewVersion':
                return 'previewPage';

            case 'edit':
                return 'editPage';

            case 'editProperties':
                if (isValidationDisabled) {
                    return 'objectPropertiesNoValidation';
                }
                return 'objectProperties';

            default:
                // const unhandledCase: never = this.scriptHost.editMode;
        }
    }

    /**
     * Intercept any clicks on anchor links within the iframe. External links should open in a new window to prevent
     * the UI state getting messed up, and internal links to other pages should cause a regular navigation within the UI app.
     *
     * This only applies for the master frame, tagfill dialogs are allowed to handle links however they like.
     */
    handleClickEventsOnLinks(): void {
        this.iFrameDocument.body.addEventListener('click', (e: MouseEvent) => {
            if (e.defaultPrevented) { return; }

            const link = e.target;
            if (!isAnchorElement(link)) {
                return;
            }
            const url = link.getAttribute('href');
            const internalLink = parseInternalLink(link);

            if (internalLink) {
                if (internalLink.type === 'page') {
                    this.scriptHost.navigateToPagePreview(internalLink.nodeId, internalLink.itemId);
                } else if (internalLink.type === 'file' || internalLink.type === 'image') {
                    this.scriptHost.navigateToFileOrImagePreview(internalLink.nodeId, internalLink.type, internalLink.itemId);
                }
                e.preventDefault();
            } else if (
                (this.scriptHost.editMode === 'preview' || e.ctrlKey)
                && url
                && !url.startsWith('#')
                && link.target !== '_blank'
            ) {
                this.iFrameWindow.open(url, '_blank');
                e.preventDefault();
            } else if (url.startsWith('#')) {
                // Allow anchor links, as they are fine.
                // no-op
            } else if (link.target !== '_blank') {
                // TODO: Show modal with link?
                e.preventDefault();
            }
        }, true);

        /**
         * Intercept mousedown events in order to correctly handle internal links when opening
         * in a new tab or a new window either with the middle mouse button or by ctrl + clicking.
         */
        this.iFrameDocument.body.addEventListener('mousedown', (e: MouseEvent) => {
            if (e.defaultPrevented) { return; }

            const target = e.target;
            // Middle mouse click can be determined either by the `which` or `button` property depending on browser.
            const middleMouseClick = e.which === 2 || e.button === 1;
            const controlKeyPressed = e.ctrlKey;
            const shiftKeyPressed = e.shiftKey;

            if (!isAnchorElement(target) || !(middleMouseClick || controlKeyPressed || shiftKeyPressed)) {
                return;
            }

            const internalLink = parseInternalLink(target);
            if (!internalLink) {
                return;
            }

            if (internalLink.type === 'page') {
                // We open the internal link in a new window and cause the entire UI app to load
                // in that window, rather than just the linked page.
                const newUrl = this.scriptHost.getInternalLinkUrlToPagePreview(internalLink.nodeId, internalLink.itemId);
                this.iFrameWindow.open(newUrl, '_blank');
            }

            e.preventDefault();
        });

        /**
         * Intercept contextmenu to handle the case where internal links are opened in a new tab / window. In this case,
         * we want to cause the whole UI app to be loaded into that new window with the correct URL pointing to
         * the page which was clicked.
         *
         * This is done by temporarily changing the href of the link when the context menu is opened, and then changing
         * it back once the link loses focus.
         */
        this.iFrameDocument.body.addEventListener('contextmenu', (e: MouseEvent) => {
            if (e.defaultPrevented) {
                return;
            }

            const target = e.target;
            if (!isAnchorElement(target)) {
                return;
            }

            const internalLink = parseInternalLink(target);

            if (!internalLink || internalLink.type !== 'page') {
                return;
            }

            const originalHref = target.getAttribute('href');
            target.href = this.scriptHost.getInternalLinkUrlToPagePreview(internalLink.nodeId, internalLink.itemId);
            const resetHref = (): void => {
                target.setAttribute('href', originalHref);
                target.removeEventListener('blur', resetHref);
            };
            target.addEventListener('blur', resetHref);
        });
    }

    notifyWhenContentsChange(): void {
        this.listenToAlohaEvents();
        this.periodicallyPollAlohaModified();
        this.notifyWhenPageIsModifiedViaJsLib();
    }

    /**
     * TODO: The "correct" way to do this would be to use the `Aloha.isModified()` method to check.
     * However, currently this is completely unreliable - see https://jira.gentics.com/browse/SUP-3985
     *
     * For the time being we rely on the `aloha-smart-content-changed` event, which unfortunately
     * fires immediately after loading the page in some cases. Therefore, we ignore the first event.
     */
    listenToAlohaEvents(): void {
        if (!this.iFrameDocument || !this.iFrameDocument.body || !this.iFrameWindow.Aloha || typeof this.iFrameWindow.Aloha.bind !== 'function') {
            return;
        }

        const initialTime = new Date().getTime();
        let isFirstChangeEvent = true;

        this.iFrameWindow.Aloha.bind('aloha-smart-content-changed', (event: Event) => {
            const delay = event.timeStamp - initialTime;

            // Ignore the `smart-content-changed` fired when opening the page
            if ((!isFirstChangeEvent || delay > 3000) && this.iFrameWindow.Aloha.isModified()) {
                this.editablesChanged = true;
                this.scriptHost.setContentModified(true);
            }
            isFirstChangeEvent = false;
        });
    }

    /**
     * Not all AlohaEditor plugins trigger the `aloha-smart-content-changed` event when something is changed.
     * As a hack, we poll for the Aloha.isModified() state, until the content is marked modified.
     */
    periodicallyPollAlohaModified(): void {
        this.iFrameWindow.setInterval(() => {
            if (!this.scriptHost.contentFrame.contentModified
                && this.iFrameWindow.Aloha
                && this.iFrameWindow.Aloha.isModified
                && this.iFrameWindow.Aloha.isModified()
            ) {
                this.scriptHost.setContentModified(true);
            }
        }, 1000);
    }

    notifyWhenPageIsModifiedViaJsLib(): void {
        // eslint-disable-next-line prefer-const
        let checkIfPageWasModifiedWhenPageIsUpdated: () => void;

        const pollForGCNObject = () => {
            if (this.iFrameWindow.Aloha && this.iFrameWindow.Aloha.GCN && this.iFrameWindow.Aloha.GCN.page) {
                checkIfPageWasModifiedWhenPageIsUpdated();
                this.observeAllGCNJsLibAjaxRequests();
            } else {
                setTimeout(pollForGCNObject, 50);
            }
        };

        checkIfPageWasModifiedWhenPageIsUpdated = () => {
            const GCN = this.iFrameWindow.Aloha.GCN;

            let originalPageContents = GCN.page._data;
            let originalPageJSON = this.safelyStringifyAlohaPageObject(originalPageContents);

            // eslint-disable-next-line @typescript-eslint/unbound-method
            const originalUpdate = GCN.page._update;
            GCN.page._update = (path, value, error, force) => {
                const returnValue = originalUpdate.call(GCN.page, path, value, error, force);

                if (!this.pageIsSavingFromSaveButton) {
                    let modified = this.editablesChanged;
                    if (!modified) {
                        const pageContents = GCN.page._data;
                        const pageContentsJSON = this.safelyStringifyAlohaPageObject(pageContents);
                        modified = (pageContents !== originalPageContents) || (pageContentsJSON !== originalPageJSON);
                    }

                    this.scriptHost.setContentModified(modified);
                }

                return returnValue;
            };

            this.scriptHost.onPageStartSaving(() => {
                this.pageIsSavingFromSaveButton = true;
            });

            this.scriptHost.onPageSaved(() => {
                this.pageIsSavingFromSaveButton = false;
                this.editablesChanged = false;
                originalPageContents = GCN.page._data;
                originalPageJSON = this.safelyStringifyAlohaPageObject(originalPageContents);
            });
        };

        pollForGCNObject();
    }

    observeAllGCNJsLibAjaxRequests(): void {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        const originalAjax = this.iFrameWindow.Aloha.GCN.page._ajax;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;

        this.iFrameWindow.Aloha.GCN.page._ajax = function wrappedJslibAjax(requestOptions: GCNJsLibRequestOptions): void {
            self.beforeJsLibAjaxRequest(requestOptions);

            // eslint-disable-next-line @typescript-eslint/unbound-method
            const originalSuccess = requestOptions.success;
            requestOptions.success = data => {
                self.afterJsLibAjaxRequest(data, requestOptions);
                return originalSuccess(data);
            };

            return originalAjax.call(this, requestOptions);
        };
    }

    beforeJsLibAjaxRequest(requestOptions: GCNJsLibRequestOptions): void {
        if (/rest\/.+\/save/.test(requestOptions.url)) {
            // A page / tag / object property is about to be saved
            this.scriptHost.setContentModified(true);
        }
    }

    afterJsLibAjaxRequest(data: any, requestOptions: GCNJsLibRequestOptions): void {
        // TODO: If the whole page is saved in an AJAX request, we could run "setContentModified(false)"

        if (!this.pageIsSavingFromSaveButton && /rest\/.+\/save/.test(requestOptions.url)) {
            // A page / tag / object property was saved
            this.scriptHost.setContentModified(true);
        }

        if (/\/rest\/page\/save/.test(requestOptions.url)) {
            this.pageIsSavingFromSaveButton = false;
        }
    }

    /**
     * Safely stringifies a Page object obtained from the Aloha.GCN plugin.
     * This Page object is aumented by the Aloha.GCN plugin and may contain
     * a reference to itself in the pageVariants and possibly the languageVariants arrays.
     */
    private safelyStringifyAlohaPageObject(page: Page): string {
        const copy = {
            ...page,
        };
        delete copy.pageVariants;
        delete copy.languageVariants;
        return JSON.stringify(copy);
    }
}

function isAnchorElement(element: any): element is HTMLAnchorElement {
    return element && element.tagName === 'A';
}

/** Checks for an internal alohapage link and if found, parses that link to extract the pageId and nodeId */
function parseInternalLink(anchor: HTMLAnchorElement): InternalLink | null {

    // Attempt to load the link-data from the attributes first, if present
    if (anchor.hasAttribute(ATTR_REPO) && anchor.getAttribute(ATTR_REPO) === REPO_CMS_ITEM) {
        const objId = anchor.getAttribute(ATTR_OBJECT_ID);
        const nodeId = parseInt(anchor.getAttribute(ATTR_NODE_ID), 10);

        if (objId && Number.isInteger(nodeId)) {
            const split = objId.split('.');
            const type = typeIdsToName(parseInt(split[0], 10));

            if (type) {
                return {
                    itemId: parseInt(split[1], 10),
                    type: type as any,
                    nodeId: nodeId,
                }
            }
        }
    }

    const href = anchor.getAttribute('href');
    let parsed: URL;
    try {
        parsed = new URL(href, window.location as any);
    } catch (err) {
        return null;
    }

    if (parsed.pathname.startsWith(ALOHAPAGE_URL)) {
        return parseInternalPageLink(anchor, parsed);
    } else if (parsed.pathname.startsWith(FILE_LINK_PREFIX)) {
        return parseInternalFileLink(anchor, parsed);
    }

    return null;
}

function parseInternalPageLink(anchor: HTMLAnchorElement, parsed: URL): InternalLink | null {
    // A link created by the GCN Links plugin has the following data attribute when in edit mode
    const isEditModeLink = !!anchor.dataset['gcnI18nConstructname'];

    // UI elements which are only an anchor for keyboard focus purposes should not be handled
    const isPresentationalLink = anchor.getAttribute('role') === 'presentation';

    if (isEditModeLink || isPresentationalLink) {
        return null;
    }

    const nodeId = parsed.searchParams.get('nodeid');
    const pageId = parsed.searchParams.get('realid');

    if (!nodeId || !pageId) {
        return null;
    }

    return {
        nodeId: parseInt(nodeId, 10),
        type: 'page',
        itemId: parseInt(pageId, 10),
    };
}

function parseInternalFileLink(anchor: HTMLAnchorElement, parsed: URL): InternalLink | null {
    const id = parseInt(parsed.pathname.substring(FILE_LINK_PREFIX.length + 1), 10);

    if (!Number.isInteger(id)) {
        return null;
    }

    let type = 'file';
    const objId = anchor.getAttribute(ATTR_OBJECT_ID);
    const nodeId = parseInt(parsed.searchParams.get('nodeId'), 10);

    if (objId) {
        const typeId = parseInt(objId.split('.')[0], 10);
        type = typeIdsToName(typeId) || type;
    }

    return {
        nodeId,
        type: type as any,
        itemId: id,
    };
}
