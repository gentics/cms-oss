/* Generated By:JJTree: Do not edit this line. ASTAssignment.java */

package com.gentics.lib.expressionparser.parser;

import com.gentics.api.lib.expressionparser.EvaluableExpression;
import com.gentics.api.lib.expressionparser.Expression;
import com.gentics.api.lib.expressionparser.ExpressionEvaluator;
import com.gentics.api.lib.expressionparser.ExpressionParser;
import com.gentics.api.lib.expressionparser.ExpressionParserException;
import com.gentics.api.lib.expressionparser.ExpressionQueryRequest;
import com.gentics.api.lib.expressionparser.filtergenerator.DatasourceFilter;
import com.gentics.api.lib.expressionparser.filtergenerator.FilterGeneratorException;
import com.gentics.api.lib.expressionparser.filtergenerator.FilterPart;
import com.gentics.api.lib.resolving.PropertySetter;
import com.gentics.lib.expressionparser.AssignmentException;
import com.gentics.lib.log.NodeLogger;

public class ASTAssignment extends SimpleNode implements EvaluableExpression {
	protected final static int TYPE_UNKNOWN = 0;

	protected final static int TYPE_ASSIGNTO = 1;

	protected final static int TYPE_ADDTO = 2;

	protected final static int TYPE_REMOVEFROM = 3;

	protected int operatorType = TYPE_UNKNOWN;

	protected String operator;

	/**
	 * for storing the "static" status of this node
	 */
	protected Boolean isStatic = null;

	/**
	 * for storing the "variable" status of this node
	 */
	protected Boolean isVariable = null;

	public ASTAssignment(int id) {
		super(id);
	}

	public ASTAssignment(Parser p, int id) {
		super(p, id);
	}

	public void setOperator(String operator) {
		this.operator = operator;
		if ("=".equals(operator)) {
			operatorType = TYPE_ASSIGNTO;
		} else if ("+=".equals(operator)) {
			operatorType = TYPE_ADDTO;
		} else if ("-=".equals(operator)) {
			operatorType = TYPE_REMOVEFROM;
		}
	}

	public String toString() {
		return operator + " (Assignment)";
	}

	/* (non-Javadoc)
	 * @see com.gentics.lib.expressionparser.Expression#getExpressionString()
	 */
	public String getExpressionString() {
		if (parent instanceof Expression) {
			return ((Expression) parent).getExpressionString();
		} else {
			return null;
		}
	}

	/* (non-Javadoc)
	 * @see com.gentics.api.lib.expressionparser.EvaluableExpression#generateFilterPart(com.gentics.api.lib.expressionparser.ExpressionQueryRequest, com.gentics.api.lib.expressionparser.filtergenerator.FilterPart, int)
	 */
	public void generateFilterPart(ExpressionQueryRequest request, FilterPart filterPart,
			int expectedValueType) throws ExpressionParserException {
		throw new FilterGeneratorException("Cannot generate filterpart for assignment");
	}

	/* (non-Javadoc)
	 * @see com.gentics.api.lib.expressionparser.EvaluableExpression#evaluate(com.gentics.api.lib.expressionparser.ExpressionQueryRequest, int)
	 */
	public Object evaluate(ExpressionQueryRequest request, int expectedValueType) throws ExpressionParserException {
		if (expectedValueType != ExpressionEvaluator.OBJECTTYPE_ANY && expectedValueType != ExpressionEvaluator.OBJECTTYPE_ASSIGNMENT) {
			throw new AssignmentException(
					"Cannot perform assignment: result value of type {" + ExpressionEvaluator.getValuetypeName(expectedValueType) + "} was expected.");
		}
		if (!(request.getResolver() instanceof PropertySetter)) {
			throw new AssignmentException("Error while performing assignment: cannot assign without propertySetter");
		}
		PropertySetter propertySetter = (PropertySetter) request.getResolver();

		// left part of the assignment must be a name, right part must be
		// evaluable
		if (children == null || children.length < 2 || !(children[0] instanceof ASTName) || !(children[1] instanceof EvaluableExpression)) {
			throw new AssignmentException("Error while performing assignment: not enough subparts found or incompatible subparts found");
		}

		ASTName leftHandSide = (ASTName) children[0];
		EvaluableExpression rightHandSide = (EvaluableExpression) children[1];

		try {
			// evaluate the rhs value
			Object rightValue = rightHandSide.evaluate(request, ExpressionEvaluator.OBJECTTYPE_ANY);

			if (rightValue == null && ExpressionParser.isCompatibilityTestMode()) {
				// when the rhs value is null and we are running in
				// compatibility test mode, output a warning
				NodeLogger.getNodeLogger(getClass()).warn(
						"Assignment expression {" + getExpressionString() + "} resolved righthandside into a null-value."
						+ " Maybe a string literal should be enclosed by \"\"?");
			}

			switch (operatorType) {
			case TYPE_ASSIGNTO:
				propertySetter.setProperty(leftHandSide.getObjectName(), rightValue);
				break;

			case TYPE_ADDTO:
				propertySetter.addToProperty(leftHandSide.getObjectName(), rightValue);
				break;

			case TYPE_REMOVEFROM:
				propertySetter.removeFromProperty(leftHandSide.getObjectName(), rightValue);
				break;

			default:
				throw new AssignmentException("Error while performing assignment: unknown assignment operator {" + operator + "}");
			}
		} catch (AssignmentException e) {
			throw e;
		} catch (Exception e) {
			throw new AssignmentException("Error while performing assignment", e);
		}

		return ExpressionParser.ASSIGNMENT;
	}

	/* (non-Javadoc)
	 * @see com.gentics.lib.expressionparser.EvaluableExpression#isStatic(com.gentics.lib.expressionparser.filtergenerator.DatasourceFilter)
	 */
	public boolean isStatic(DatasourceFilter filter) throws ExpressionParserException {
		if (isStatic == null) {
			boolean tempIsStatic = true;

			for (int i = 0; i < children.length && tempIsStatic; ++i) {
				if (children[i] instanceof EvaluableExpression) {
					tempIsStatic &= ((EvaluableExpression) children[i]).isStatic(filter);
				}
			}
			isStatic = Boolean.valueOf(tempIsStatic);
		}
		return isStatic.booleanValue();
	}

	/* (non-Javadoc)
	 * @see com.gentics.lib.expressionparser.EvaluableExpression#isVariable(com.gentics.lib.expressionparser.filtergenerator.DatasourceFilter)
	 */
	public boolean isVariable(DatasourceFilter filter) throws ExpressionParserException {
		if (isVariable == null) {
			// when no function is registered for the datasource class, this will fail
			boolean tempIsVariable = false;

			for (int i = 0; i < children.length && !tempIsVariable; ++i) {
				if (children[i] instanceof EvaluableExpression) {
					tempIsVariable |= ((EvaluableExpression) children[i]).isVariable(filter);
				}
			}

			// FIXME throw an exception when the expression is variable?
			isVariable = Boolean.valueOf(tempIsVariable);
		}

		return isVariable.booleanValue();
	}

	/* (non-Javadoc)
	 * @see com.gentics.api.lib.expressionparser.EvaluableExpression#allowsNullValues()
	 */
	public boolean allowsNullValues(DatasourceFilter filter) throws ExpressionParserException {
		return false;
	}

	/* (non-Javadoc)
	 * @see com.gentics.api.lib.expressionparser.EvaluableExpression#getExpectedValueType(com.gentics.api.lib.expressionparser.filtergenerator.DatasourceFilter)
	 */
	public int getExpectedValueType(DatasourceFilter filter) throws ExpressionParserException {
		return ExpressionEvaluator.OBJECTTYPE_ASSIGNMENT;
	}
}
