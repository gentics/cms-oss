import { AlohaIntegrationService } from '@editor-ui/app/content-frame/providers/aloha-integration/aloha-integration.service';
import { AlohaContextChangeEvent, AlohaPubSub } from '@gentics/aloha-models';
import { Page } from '@gentics/cms-models';
import { ALOHAPAGE_URL } from '../../../../common/utils/base-urls';
import { CustomScriptHostService } from '../../../providers/custom-script-host/custom-script-host.service';
import { CNIFrameDocument, CNWindow, DYNAMIC_FRAME, GCNImagePlugin, GCNJsLibRequestOptions, appendTypeIdToUrl } from '../common';

// Force TypeScript to report errors when using the global window/document object
let document: never;
let window: never;

export const OBJECT_PROPERTIES_CONTEXT_MENU_CLASS = 'custom-object-properties-context-menu-button';

export const OBJECT_PROPERTIES_INFO_BUTTON_CLASS = 'custom-object-properties-info-button';

const TAGFILL_FORM_SELECTOR = 'form[name="tagfill"]';
const MULTIPAGE_FORM_SELECTOR = 'form[name="ds_sel"], form[name="dsdef"]';

/**
 * This will execute in the context of the IFrame, when the code inside it calls the `GCMSUI.runPostLoadScript()` method.
 * This occurs when the document's `load` event fires (i.e. full document and all resources are loaded).
 *
 * Scripts that need to manipulate DOM which may itself be generated by other scripts on the page (such as the tagfill
 * stuff) needs to go in here.
 *
 * For scripts that do not rely on generated DOM, use the pre-load function.
 *
 * We pass in the instance of the ScriptHost so that we can refer back to that scope and interact directly it.
 */
export class PostLoadScript {

    private editablesChanged = false;
    private pageIsSaving = false;
    private pageIsSavingFromSaveButton = false;
    private objPropIsValid = true;

    constructor(
        private window: CNWindow,
        private document: CNIFrameDocument,
        private scriptHost: CustomScriptHostService,
        private aloha: AlohaIntegrationService,
    ) { }

    run(): void {
        this.aloha.reference$.next(this.window.Aloha);

        let innerSettings = this.window.Aloha.settings;
        this.aloha.settings$.next(innerSettings);

        let innerGcnPlugin = this.window.Aloha.GCN as any;
        this.aloha.gcnPlugin$.next(innerGcnPlugin);

        Object.defineProperty(this.window.Aloha, 'settings', {
            configurable: true,
            enumerable: true,
            get: () => {
                return innerSettings;
            },
            set: (newSettings) => {
                innerSettings = newSettings;
                this.aloha.settings$.next(innerSettings);
            },
        });

        Object.defineProperty(this.window.Aloha, 'GCN', {
            configurable: true,
            enumerable: true,
            get: () => {
                return innerGcnPlugin;
            },
            set: (newPlugin) => {
                innerGcnPlugin = newPlugin;
                this.aloha.gcnPlugin$.next(innerGcnPlugin);
            },
        });

        // Update to the current selection
        this.aloha.contextChange$.next(this.window.Aloha.Selection.getRangeObject());

        const pubSub: AlohaPubSub = this.window.Aloha.require('PubSub');
        if (pubSub) {
            pubSub.sub('aloha.selection.context-change', (event: AlohaContextChangeEvent) => {
                this.aloha.contextChange$.next(event.range);
            });
        }

        this.window.addEventListener('unload', () => {
            this.aloha.contextChange$.next(null);
            this.aloha.settings$.next(null);
            this.aloha.reference$.next(null);
        });

        // Determine which type of editor frame is opened (previewing page, tagfill, ...)
        const editFrameType = this.determineEditFrameType();

        // Depending on the frame type, do the right things
        switch (editFrameType) {
            case 'tagfill':
                this.appendTypeIdToTagfillForm();
                break;

            case 'objectProperties':
                this.setObjPropValidStateAccordingToEditingStep();
                this.notifyWhenObjectPropertiesChange();
                break;

            case 'objectPropertiesNoValidation':
                break;

            case 'editImage':
                this.handleImageEditingEvents();
                break;

            case 'editPage':
            case 'previewPage':
                this.handleClickEventsOnLinks();
                this.notifyWhenContentsChange();
                break;
        }

        this.scriptHost.runChangeDetection();
    }

    determineEditFrameType(): 'tagfill' | 'editPage' | 'editImage' | 'objectProperties' | 'objectPropertiesNoValidation' | 'previewPage' {
        const frameElement = this.window.frameElement as HTMLElement;
        const isDynamicFrame = frameElement && frameElement.dataset[DYNAMIC_FRAME] === 'true';
        const isValidationDisabled = frameElement && frameElement.dataset['disableValidation'] === 'true';

        if (isDynamicFrame) {
            return 'tagfill';
        }

        const objectPropertiesOkayButton = this.document.querySelector('input[type="image"][name="factionok"]');
        if (objectPropertiesOkayButton) {
            return 'objectProperties';
        }

        if (this.document && this.document.body &&
            this.document.body.dataset['itemType'] === 'image' &&
            this.document.body.dataset['editMode'] === 'edit') {
            return 'editImage';
        }

        switch (this.scriptHost.editMode) {
            case 'compareVersionContents':
            case 'compareVersionSources':
            case 'preview':
            case 'previewVersion':
                return 'previewPage';

            case 'edit':
                return 'editPage';

            case 'editProperties':
                if (isValidationDisabled) {
                    return 'objectPropertiesNoValidation';
                }
                return 'objectProperties';

            default:
                // const unhandledCase: never = this.scriptHost.editMode;
        }
    }

    appendTypeIdToTagfillForm(): void {
        const tagfillForm: HTMLFormElement = this.document.querySelector(TAGFILL_FORM_SELECTOR) ;
        if (tagfillForm && tagfillForm.tagName === 'FORM') {
            tagfillForm.action = appendTypeIdToUrl(this.scriptHost.currentItem, tagfillForm.action);
        }
    }

    notifyWhenObjectPropertiesChange(): void {
        this.notifyIfPageWasReloadedAfterModifying();

        const form = this.document.querySelector(TAGFILL_FORM_SELECTOR) || this.document.querySelector(MULTIPAGE_FORM_SELECTOR);
        if (form) {
            const tagfillInputs: Array<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement> =
                Array.prototype.slice.call(form.querySelectorAll('input:not([type="hidden"]):not([type="image"]), textarea, select'));

            for (const input of tagfillInputs) {
                for (const eventName of ['input', 'change']) {
                    input.addEventListener(eventName, () => this.scriptHost.setObjectPropertyModified(true, this.objPropIsValid));
                }
            }
        }

        this.scriptHost.onSaveObjectProperty(() => {
            this.scriptHost.setObjectPropertyModified(false, true);
            const isMultipageTagfill = this.isMultipageTagfill();

            // Use factionapply to reload the form after save or factionnext for multipage forms
            const action = !isMultipageTagfill ? 'factionapply' : 'factionnext';
            if (this.submitTagfillForm(action)) {
                // Return a promise which resolves after the changes were actually saved in the backend
                return new Promise(resolve => {
                    this.window.addEventListener('unload', () => {
                        resolve({});
                        // Since we have to use factionnext to save a multipage form, the page would be empty after saving.
                        // Thus we navigate back to the last page after the save completes.
                        if (isMultipageTagfill) {
                            setTimeout(() => this.window.history.back());
                        }
                    });
                });
            } else {
                return Promise.resolve();
            }
        });
    }

    /**
     * Hack of the Year!
     * ----------------
     * (Michael Bromley @ 2016-08-11)
     *
     * It seems like the Content Node backend only saves changes to the object property if the "okay" button is
     * clicked by a human (calling .click() on it programatically will not work).
     * I have deduced that this is because the "okay" button is actually an `input[type="image"]`, and the
     * backend is inspecting the .x & .y values (which denote where the image was clicked). When .click() is called
     * programatically (or the form submitted programatically via .submit()), these values both === 0.
     * When a human clicks the button, they are always some positive integer.
     *
     * So here I am simulating a human click by creating my own hidden form inputs which, when serialized in the
     * POST request, will appear identical to the 2 values generated by the image input.
     *
     * Same applies to the "cancel" button.
     *
     * @returns true if the form is actually being submitted and false if no form was found to be submitted
     */
    submitTagfillForm(inputName: string, form?: HTMLFormElement): boolean {
        if (!form) {
            const formNames = ['tagfill', 'ds_sel', 'dsdef'];
            const allForms = Array.from(this.document.querySelectorAll('form'));

            for (const name of formNames) {
                form = allForms.find(form => form.name === name);
                if (form) {
                    break;
                }
            }

            // Occurs when the object properties are opened, but no specific object property is selected.
            if (!form) {
                return false;
            }
        }

        for (const coord of ['x', 'y']) {
            const fakeImageInput = this.document.createElement('input');
            fakeImageInput.name = `${inputName}.${coord}`;
            fakeImageInput.type = 'hidden';
            fakeImageInput.value = '10';
            form.appendChild(fakeImageInput);
        }
        form.submit();
        return true;
    }

    notifyIfPageWasReloadedAfterModifying(): void {
        const targetUrlSegment = 'faction=%C3%9Cbernehmen';
        const alreadyModified = this.window.location.href.indexOf(targetUrlSegment) >= 0;
        this.scriptHost.setObjectPropertyModified(alreadyModified, this.objPropIsValid);
    }

    /** Bind to the crop & resize events and set up the ContentFrame to handle making a save request */
    handleImageEditingEvents(): void {
        if (!this.window.Aloha || !this.window.Aloha.require) {
            return;
        }

        this.window.Aloha.require(['jquery', 'gcn-image/gcn-image-plugin'], ($: JQueryStatic, gcnImagePlugin: GCNImagePlugin) => {

            $('body').on('aloha-image-resized aloha-image-cropped', () => {
                this.scriptHost.setImageResizedOrCropped();
            });

            $('body').on('aloha-image-focalpoint', () => {
                this.scriptHost.setContentModified(true);
            });

            $('body').on('aloha-image-reset', () => {
                this.scriptHost.setContentModified(false);
            });

            this.scriptHost.onGetFocalPoint(() => {
                const { fpX, fpY } = gcnImagePlugin.imageProperties;
                return { fpX, fpY };
            });

            /** Build the parameters needed for a call to `image/resize`. */
            this.scriptHost.onGetCropResizeParams(() => {
                const image = gcnImagePlugin.imageProperties;
                const info = image.info;
                const fileExt = image.name.substr(image.name.lastIndexOf('.') + 1).toLowerCase();
                const format: 'png' | 'jpg' = fileExt === 'jpg' || fileExt === 'jpeg' ? 'jpg' : 'png';

                return {
                    image: {
                        id: image.id,
                    },
                    cropHeight: info.ch,
                    cropWidth: info.cw,
                    cropStartX: info.x,
                    cropStartY: info.y,
                    fpX: image.fpX,
                    fpY: image.fpY,
                    width: info.w,
                    height: info.h,
                    mode: 'cropandresize',
                    resizeMode: 'force',
                    targetFormat: format,
                    copyFile: false,
                };
            });
        });
    }

    /**
     * Intercept any clicks on anchor links within the iframe. External links should open in a new window to prevent
     * the UI state getting messed up, and internal links to other pages should cause a regular navigation within the UI app.
     *
     * This only applies for the master frame, tagfill dialogs are allowed to handle links however they like.
     */
    handleClickEventsOnLinks(): void {
        this.document.body.addEventListener('click', (e: MouseEvent) => {
            if (e.defaultPrevented) { return; }

            const link = e.target;
            if (isAnchorElement(link)) {
                const url = link.getAttribute('href');
                const internalLink = parseInternalLink(link);

                if (internalLink) {
                    this.scriptHost.navigateToPagePreview(internalLink.nodeId, internalLink.pageId);
                    e.preventDefault();
                } else if (this.scriptHost.editMode === 'preview' && url && !url.startsWith('#') && link.target !== '_blank') {
                    this.window.open(url, '_blank');
                    e.preventDefault();
                }
            }
        }, true);

        /**
         * Intercept mousedown events in order to correctly handle internal links when opening
         * in a new tab or a new window either with the middle mouse button or by ctrl + clicking.
         */
        this.document.body.addEventListener('mousedown', (e: MouseEvent) => {
            if (e.defaultPrevented) { return; }

            const target = e.target;
            // Middle mouse click can be determined either by the `which` or `button` property depending on browser.
            const middleMouseClick = e.which === 2 || e.button === 1;
            const controlKeyPressed = e.ctrlKey;
            const shiftKeyPressed = e.shiftKey;

            if (isAnchorElement(target) && (middleMouseClick || controlKeyPressed || shiftKeyPressed)) {
                const internalLink = parseInternalLink(target);
                if (internalLink) {
                    // We open the internal link in a new window and cause the entire UI app to load
                    // in that window, rather than just the linked page.
                    const newUrl = this.scriptHost.getInternalLinkUrlToPagePreview(internalLink.nodeId, internalLink.pageId);
                    this.window.open(newUrl, '_blank');
                    e.preventDefault();
                }
            }
        });

        /**
         * Intercept contextmenu to handle the case where internal links are opened in a new tab / window. In this case,
         * we want to cause the whole UI app to be loaded into that new window with the correct URL pointing to
         * the page which was clicked.
         *
         * This is done by temporarily changing the href of the link when the context menu is opened, and then changing
         * it back once the link loses focus.
         */
        this.document.body.addEventListener('contextmenu', (e: MouseEvent) => {
            if (e.defaultPrevented) { return; }

            const target = e.target;
            if (isAnchorElement(target)) {
                const internalLink = parseInternalLink(target);

                if (internalLink) {
                    const originalHref = target.getAttribute('href');
                    target.href = this.scriptHost.getInternalLinkUrlToPagePreview(internalLink.nodeId, internalLink.pageId);
                    const resetHref = (): void => {
                        target.setAttribute('href', originalHref);
                        target.removeEventListener('blur', resetHref);
                    };
                    target.addEventListener('blur', resetHref);
                }
            }
        });
    }

    notifyWhenContentsChange(): void {
        this.listenToAlohaEvents();
        this.periodicallyPollAlohaModified();
        this.notifyWhenPageIsModifiedViaJsLib();
    }

    /**
     * TODO: The "correct" way to do this would be to use the `Aloha.isModified()` method to check.
     * However, currently this is completely unreliable - see https://jira.gentics.com/browse/SUP-3985
     *
     * For the time being we rely on the `aloha-smart-content-changed` event, which unfortunately
     * fires immediately after loading the page in some cases. Therefore, we ignore the first event.
     */
    listenToAlohaEvents(): void {
        if (!this.document || !this.document.body || !this.window.Aloha || typeof this.window.Aloha.bind !== 'function') {
            return;
        }

        const initialTime = new Date().getTime();
        let isFirstChangeEvent = true;

        this.window.Aloha.bind('aloha-smart-content-changed', (event: Event) => {
            const delay = event.timeStamp - initialTime;

            // Ignore the `smart-content-changed` fired when opening the page
            if ((!isFirstChangeEvent || delay > 3000) && this.window.Aloha.isModified()) {
                this.editablesChanged = true;
                this.scriptHost.setContentModified(true);
            }
            isFirstChangeEvent = false;
        });
    }

    /**
     * Not all AlohaEditor plugins trigger the `aloha-smart-content-changed` event when something is changed.
     * As a hack, we poll for the Aloha.isModified() state, until the content is marked modified.
     */
    periodicallyPollAlohaModified(): void {
        this.window.setInterval(() => {
            if (!this.scriptHost.contentFrame.contentModified && this.window.Aloha && this.window.Aloha.isModified()) {
                this.scriptHost.setContentModified(true);
            }
        }, 1000);
    }

    notifyWhenPageIsModifiedViaJsLib(): void {
        let checkIfPageWasModifiedWhenPageIsUpdated: () => void;

        const pollForGCNObject = () => {
            if (this.window.Aloha && this.window.Aloha.GCN && this.window.Aloha.GCN.page) {
                checkIfPageWasModifiedWhenPageIsUpdated();
                this.observeAllGCNJsLibAjaxRequests();
            } else {
                setTimeout(pollForGCNObject, 50);
            }
        };

        checkIfPageWasModifiedWhenPageIsUpdated = () => {
            const GCN = this.window.Aloha.GCN;

            let originalPageContents = GCN.page._data;
            let originalPageJSON = this.safelyStringifyAlohaPageObject(originalPageContents);

            const originalUpdate = GCN.page._update;
            GCN.page._update = (path, value, error, force) => {
                const returnValue = originalUpdate.call(GCN.page, path, value, error, force);

                if (!this.pageIsSavingFromSaveButton) {
                    let modified = this.editablesChanged;
                    if (!modified) {
                        const pageContents = GCN.page._data;
                        const pageContentsJSON = this.safelyStringifyAlohaPageObject(pageContents);
                        modified = (pageContents !== originalPageContents) || (pageContentsJSON !== originalPageJSON);
                    }

                    this.scriptHost.setContentModified(modified);
                }

                return returnValue;
            };

            this.scriptHost.onPageStartSaving(() => {
                this.pageIsSavingFromSaveButton = true;
            });

            this.scriptHost.onPageSaved(() => {
                this.pageIsSavingFromSaveButton = false;
                this.editablesChanged = false;
                originalPageContents = GCN.page._data;
                originalPageJSON = this.safelyStringifyAlohaPageObject(originalPageContents);
            });
        };

        pollForGCNObject();
    }

    observeAllGCNJsLibAjaxRequests(): void {
        const originalAjax = this.window.Aloha.GCN.page._ajax;
        const self = this;

        this.window.Aloha.GCN.page._ajax = function wrappedJslibAjax(requestOptions: GCNJsLibRequestOptions): void {
            self.beforeJsLibAjaxRequest(requestOptions);

            const originalSuccess = requestOptions.success;
            requestOptions.success = data => {
                self.afterJsLibAjaxRequest(data, requestOptions);
                return originalSuccess(data);
            };

            return originalAjax.call(this, requestOptions);
        };
    }

    beforeJsLibAjaxRequest(requestOptions: GCNJsLibRequestOptions): void {
        if (/rest\/.+\/save/.test(requestOptions.url)) {
            // A page / tag / object property is about to be saved
            this.scriptHost.setContentModified(true);
        }

        if (/\/rest\/page\/save/.test(requestOptions.url)) {
            this.pageIsSaving = false;
        }
    }

    afterJsLibAjaxRequest(data: any, requestOptions: GCNJsLibRequestOptions): void {
        // TODO: If the whole page is saved in an AJAX request, we could run "setContentModified(false)"

        if (!this.pageIsSavingFromSaveButton && /rest\/.+\/save/.test(requestOptions.url)) {
            // A page / tag / object property was saved
            this.scriptHost.setContentModified(true);
        }

        if (/\/rest\/page\/save/.test(requestOptions.url)) {
            this.pageIsSaving = this.pageIsSavingFromSaveButton = false;
        }
    }

    isFormGeneratorTagfill(): boolean {
        return this.document.querySelector('#fg-form') != null;
    }

    isMultipageTagfill(): boolean {
        return this.document.querySelector(MULTIPAGE_FORM_SELECTOR) != null;
    }

    handleFormGeneratorSaveButton(customOkayButton: HTMLButtonElement): void {
        customOkayButton.classList.add('disabled');
        customOkayButton.disabled = true;

        this.document.addEventListener('click', event => {
            const target = event.target as HTMLElement;
            if (isFormGeneratorSaveButton(target)) {
                customOkayButton.classList.remove('disabled');
                customOkayButton.removeAttribute('disabled');
            }
        });
    }

    /**
     * Safely stringifies a Page object obtained from the Aloha.GCN plugin.
     * This Page object is aumented by the Aloha.GCN plugin and may contain
     * a reference to itself in the pageVariants and possibly the languageVariants arrays.
     */
    private safelyStringifyAlohaPageObject(page: Page): string {
        const copy = {
            ...page,
        };
        delete copy.pageVariants;
        delete copy.languageVariants;
        return JSON.stringify(copy);
    }

    /**
     * Enables the save button for the object property if we are either not in a multipage tagfill
     * or if we are on the last page of a multipage tagfill. Otherwise it disables the button.
     */
    private setObjPropValidStateAccordingToEditingStep(): void {
        this.objPropIsValid = true;
        if (this.isMultipageTagfill()) {
            // If we are in a multipage tagfill and there is a "next" button, we know that we
            // are not on the last page and thus saving should not be possible yet.
            const nextButton = this.document.querySelector('.gcms-custom-tagfill-button.role-next');
            if (nextButton) {
                this.objPropIsValid =  false;
            }
        }
        this.scriptHost.setObjectPropertyModified(false, this.objPropIsValid);
    }

}

function noop(): void { }

function isAnchorElement(element: any): element is HTMLAnchorElement {
    return element && element.tagName === 'A';
}

/** Checks for an internal alohapage link and if found, parses that link to extract the pageId and nodeId */
function parseInternalLink(anchor: HTMLAnchorElement): { nodeId: number; pageId: number; } | undefined {
    const href = anchor.getAttribute('href');
    const isInternalLink = href && href.indexOf(ALOHAPAGE_URL) >= 0;

    // A link created by the GCN Links plugin has the following data attribute when in edit mode
    const isEditModeLink = !!anchor.dataset['gcnI18nConstructname'];

    // UI elements which are only an anchor for keyboard focus purposes should not be handled
    const isPresentationalLink = anchor.getAttribute('role') === 'presentation';

    if (isInternalLink && !isEditModeLink && !isPresentationalLink) {
        const nodeIdMatches = /[?&]nodeid=(\d+)/.exec(href);
        const nodeId = nodeIdMatches && +nodeIdMatches[1];
        const pageIdMatches = /[?&]realid=(\d+)/.exec(href);
        const pageId = nodeIdMatches && +pageIdMatches[1];

        if (nodeId && pageId) {
            return {
                nodeId,
                pageId,
            };
        }
    }
}

function isFormGeneratorSaveButton(element: Element): boolean {
    const selector = '#toolbar-button-save, #toolbar-button-save *';
    if (element && element.matches) {
        return element.matches(selector);
    } else if (element && (<any> element).msMatchesSelector) {
        return (<any> element).msMatchesSelector(selector);
    } else {
        return false;
    }
}
