import { Injectable } from '@angular/core';
import { File, Folder, Page } from '@gentics/cms-models';
import { isEqual } from 'lodash';
import { Subject, Subscription, combineLatest } from 'rxjs';
import { startWith, switchMap, distinctUntilChanged, map, filter } from 'rxjs/operators';
import { EditorState } from '@editor-ui/app/common/models';
import { isSameOrigin } from '../../../common/utils/is-same-origin';
import { ResourceUrlBuilder } from '../../../core/providers/resource-url-builder/resource-url-builder';
import { ApplicationStateService } from '../../../state';
import { BLANK_PAGE, BLANK_PROPERTIES_PAGE, DYNAMIC_FRAME } from '../../components/content-frame/common';
import { ContentFrame } from '../../components/content-frame/content-frame.component';
import { IFrameCollectionService } from './iframe-collection.service';
import { ManagedIFrameCollection } from './managed-iframe-collection.class';

/**
 * If an iframe's dataset contains a property with this name that is set to 'true',
 * the `IFrameManager` will ignore it. Since GCMS 5.34 script/style injection has been
 * replaced with `window.GCMSUI` methods called by the code inside the IFrame.
 */
const SKIP_SCRIPT_INJECTION_ATTR = 'gcmsUiSkipInjection';

interface MockLocation {
    href: string;
    reload: () => void;
}
// Some properties need to exist on the top window for some Content.Node iframes to work properly.
declare let window: Window & {
    ass: Object;
    main: {
        ass: {
            GTXHistory: {
                add(): void;
            }
        };
        list: {
            gtx_noass: boolean;
        };
    };
    menu: {
        location: MockLocation;
        move_menu: () => void;
    }
    logo: { location: MockLocation; }
    tree: {
        location: MockLocation;
        keepMenuThere: () => void;
    }
};

/**
 * This service is designed to encapsulate the dirty and complex methods required to manage the
 * nested iframes generated by the ContentNode-php backend.
 *
 * The heirarcy of objects is like this:
 * ------------------------------------
 *
 * ContentFrame                         // Angular component, responsible for view layer, dispatching actions;
 *                                      // translating URL into editorState actions.
 *      |
 * IFrameManager                        // Injects scripts & styles into iframes;
 *      |                               // monitors EditorState and updates url of master frame.
 *      |
 * ManagedIFrameCollection              // Aggregates the events of all iframes together.
 *      |
 *      |- ManagedIFrame (masterFrame)  // Abstracts the native IFrame element away and exposes a stream-based interface.
 *      |- ManagedIFrame (e.g. tagfill modal)
 *      |- ManagedIFrame (etc..)
 *
 * ------------------------------------
 *
 * It is only to be consumed by the ContentFrame component, so the implementation is quite
 * specific to that. Currently there is no use-case for generalizing this service, so it remains
 * tightly-coupled and resides alongside the ContentFrame component.
 *
 * Since GCMS 5.34 the GCMS UI scripts and styles are no longer injected into the IFrames, but
 * are run when the IFrame requests them to be run.
 * The GCMS UI parent window now provides the `GCMSUI_childIFrameInit()` method, which needs to be called
 * by the code inside the IFrame (`window.parent.GCMSUI_childIFrameInit()`)
 * and which is sets up the `window.GCMSUI` object for the IFrame.
 * The code inside the IFrame then needs to call the `GCMSUI.runPreLoadScript()` and the
 * `GCMSUI.runPostLoadScript()` method when the `DOMContentLoaded` and `load` events are fired respectively.
 * These methods also take care of applying the GCMS UI stylesheets to the IFrame.
 *
 * Child IFrames that require the GCMS UI scripts and styles need to proceed in the same way.
 * If their parent IFrame has executed the above steps, `window.parent.GCMSUI_childIFrameInit()`
 * will be available to the child IFrame.
 *
 * Even though there is no more script or styles injection, the
 * IFrameManager still exists and maintains its collection - there was not enough time
 * to analyze the code and check if it can be removed completely. Thus we also still check the
 * legacy `data-gcms-ui-skip-injection="true"` attribute on each IFrame (to set the attribute in JavaScript
 * write `iframe.dataset['gcmsUiSkipInjection'] = 'true'`). It just tells the IFrameManager to completely
 * disregard it completely.
 */
@Injectable()
export class IFrameManager {

    public requesting$ = new Subject<boolean>();
    public collection: ManagedIFrameCollection;

    get destroyed(): boolean {
        return this.componentWasDestroyed;
    }

    // Used to prevent memory leaks caused by the various polling functions,
    // to brute-force them to stop once this component has been destroyed.
    private componentWasDestroyed = false;
    private dispatchCloseActionOnUnload = false;
    private hostComponent: ContentFrame;
    private masterFrameClosedCallback: Function;
    private urlSubscription: Subscription;

    constructor(
        private appState: ApplicationStateService,
        private resourceUrlBuilder: ResourceUrlBuilder,
        private iframeCollectionService: IFrameCollectionService,
    ) {}

    public initialize(masterFrameElement: HTMLIFrameElement, hostComponent: ContentFrame): void {
        this.addRequiredGlobalObjects();
        this.collection = this.iframeCollectionService.create(masterFrameElement);
        this.subscribeToCollection(this.collection);
        this.hostComponent = hostComponent;

        const stateChangesToUrl$ = this.appState.select(state => state.editor).pipe(
            switchMap(state => this.stateToUrl(state)),
            distinctUntilChanged(isEqual),
        );

        const currentItemVersion$ =  this.appState.select(state => state.editor).pipe(
            map(editorState => ({
                id: editorState.itemId,
                type: editorState.itemType,
            })),
            distinctUntilChanged((a, b) => a.id === b.id && a.type === b.type),
            filter(item => item.type && item.type === 'page'),
            switchMap(item => this.appState.select(state => state.entities['page'][item.id].currentVersion)),
            startWith({} as any), // always start with a value so as to not block the subscription
        );

        this.urlSubscription = combineLatest([
            stateChangesToUrl$,
            currentItemVersion$,
        ]).pipe(
            map(([url]) => url),
        ).subscribe((url: string) => {
            this.requesting$.next(true);
            this.hostComponent.setMasterFrameLoaded(false);
            this.collection.masterFrame.setUrl(url);
        });
    }

    public destroy(): void {
        this.componentWasDestroyed = true;
        if (this.urlSubscription) {
            this.urlSubscription.unsubscribe();
        }
    }

    public onMasterFrameClosed(callback: Function): void {
        this.masterFrameClosedCallback = callback;
    }

    public initiateUserClose(): void {
        this.dispatchCloseActionOnUnload = true;
    }

    public reloadMasterFrame(): void {
        this.collection.masterFrame.reload();
        this.requesting$.next(true);
    }

    /**
     * Sets up the subscriptions and handlers for the events emitted from the ManagedIFrameCollection.
     */
    public subscribeToCollection(collection: ManagedIFrameCollection): void {

        const isMasterFrame = (id: string): boolean => {
            return collection.masterFrame.id === id;
        };

        /**
         * If the nested frame is of the same origin, then its load events also must be subscribed to.
         */
        const processChildFrame = (iframe: HTMLIFrameElement) => {
            if (isSameOrigin(window.location.href, iframe.src) && iframe.dataset[SKIP_SCRIPT_INJECTION_ATTR] !== 'true') {
                collection.add(iframe);
            }
        };

        collection.domContentLoaded$.subscribe(event => {
            // recursively check for nested IFrames, and repeat the provisioning process on them.
            const childFrames = Array.from(event.iframe.contentWindow.document.querySelectorAll('iframe')) ;
            childFrames.forEach(childFrame => {
                processChildFrame(childFrame);
            });

            // The Tag Fill links open IFrames when clicked. These also need to be provisioned.
            this.createIFrameMutationObserver(
                event.iframe.contentWindow.document.documentElement,
                addedIFrame => processChildFrame(addedIFrame),
                removedIFrame => collection.removeByNativeElement(removedIFrame),
            );
        });

        collection.load$.subscribe(event => {
            if (isMasterFrame(event.id)) {
                this.hostComponent.setMasterFrameLoaded(true);
            }
            this.requesting$.next(false);
        });

        collection.unload$.subscribe(event => {
            if (isMasterFrame(event.id)) {
                this.collection.removeAllChildren();
                this.hostComponent.setContentModified(false);
                if (this.dispatchCloseActionOnUnload) {
                    this.invokePendingUnloadCallbacks();
                    this.dispatchCloseActionOnUnload = false;
                }
            }
        });
    }

    /**
     * Sets up a MutationObserver on the given element, which watches for iframes being added to and removed from the
     * subtree. When an iframe is added or removed, the corresponding callback is executed on that iframe.
     */
    private createIFrameMutationObserver(element: HTMLElement,
        onIFrameAdded: (iframe: HTMLIFrameElement) => void,
        onIFrameRemoved: (iframe: HTMLIFrameElement) => void): void {

        const invokeCallbackOnIFrames = (m: MutationRecord) => {
            const addedNodes: Element[] = Array.from<Element>(<any> m.addedNodes);
            const removedNodes: Element[] = Array.from<Element>(<any> m.removedNodes);

            addedNodes.forEach(node => {
                if (node.tagName === 'IFRAME') {
                    const addedIFrame = node as HTMLIFrameElement;
                    // ensure the iframe has a name or an id (mainly for logging clarity)
                    if (!addedIFrame.name && !addedIFrame.id) {
                        addedIFrame.name = `gcms-dynamic-iframe-${Math.random().toString(36).substr(5, 8)}`;
                    }
                    // mark as a dynamic frame
                    addedIFrame.dataset[DYNAMIC_FRAME] = 'true';

                    // invoke the callback
                    onIFrameAdded(addedIFrame);
                }
            });
            removedNodes.forEach(node => {
                let iframes: HTMLIFrameElement[];
                if (node instanceof HTMLIFrameElement) {
                    iframes = [node];
                } else {
                    iframes = node.querySelectorAll && Array.from(node.querySelectorAll('iframe')) ;
                }
                if (iframes && 0 < iframes.length) {
                    iframes.forEach((iframe: HTMLIFrameElement) => {
                        onIFrameRemoved(iframe);
                    });
                }
            });
        };

        const iframeObserver = new MutationObserver((mutations: MutationRecord[]) => {
            mutations
                .filter(m => m.type === 'childList')
                .forEach(invokeCallbackOnIFrames);
        });

        iframeObserver.observe(element, {
            attributes: false,
            childList: true,
            characterData: false,
            subtree: true,
        });
    }


    /**
     * When a frame is unloaded, there may be callbacks waiting to execute. This methods checks for
     * any of the possible callbacks and invokes them if they exist.
     */
    private invokePendingUnloadCallbacks(): void {
        if (typeof this.masterFrameClosedCallback === 'function') {
            this.masterFrameClosedCallback();
        }
    }

    /**
     * There are a number Content.Node iframes which won't work properly unless
     * the parent frame contains an "ass" object. Sorry.
     * Also, some scripts generated by Content.Node assume certain other global objects and
     * contain code such as `top.tree.location = '...'`; so failure to define such objects
     * will result in TypeErros being thrown at runtime.
     */
    private addRequiredGlobalObjects(): void {
        const mockLocation: MockLocation = {
            href: '',
            reload(): void {},
        };
        window.ass = {};
        window.main = {
            ass: {
                GTXHistory: {
                    add(): void {},
                },
            },
            list: {
                gtx_noass: true,
            },
        };
        window.menu = {
            location: mockLocation,
            move_menu(): void {},
        };
        window.logo = {
            location: mockLocation,
        };
        window.tree = {
            location: mockLocation,
            keepMenuThere(): void {},
        };
    }

    /**
     * Returns a GCMS url to act as the src of the iframe depending on the editMode and
     * type of item being edited.
     */
    stateToUrl(editorState: EditorState): Promise<string> {
        return this.hostComponent.getCurrentItem().then(currentItem => {
            if (!editorState.editorIsOpen) {
                return BLANK_PAGE;
            }

            let url = BLANK_PAGE;
            const folderId = (<Page | File> currentItem).folderId || (<Folder> currentItem).id;
            const itemId = currentItem.id;
            const nodeId = editorState.nodeId;

            if (editorState.editMode === 'preview' || editorState.editMode === 'edit') {
                if (editorState.itemType === 'page') {
                    if (editorState.compareWithId) {
                        url = this.resourceUrlBuilder.comparePageLanguages(nodeId, itemId, editorState.compareWithId);
                    } else if (editorState.editMode === 'preview') {
                        url = this.resourceUrlBuilder.pagePreview(itemId, nodeId);
                    } else {
                        url = this.resourceUrlBuilder.pageEditor(itemId, nodeId);
                    }
                } else if (editorState.itemType === 'image') {
                    url = this.resourceUrlBuilder.imageEditor(itemId, folderId);
                }
            } else if (editorState.editMode === 'editProperties') {
                url = BLANK_PROPERTIES_PAGE;
            } else if (editorState.editMode === 'previewVersion') {
                url = this.resourceUrlBuilder.previewPageVersion(nodeId, itemId, editorState.version.timestamp);
            } else if (editorState.editMode === 'compareVersionContents') {
                url = this.resourceUrlBuilder.comparePageVersions(nodeId, itemId,
                    editorState.oldVersion.timestamp, editorState.version.timestamp);
            } else if (editorState.editMode === 'compareVersionSources') {
                url = this.resourceUrlBuilder.comparePageVersionSources(nodeId, itemId,
                    editorState.oldVersion.timestamp, editorState.version.timestamp);
            }

            return url;
        });
    }
}
